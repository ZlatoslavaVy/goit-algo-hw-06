# goit-algo-hw-06

================================================================================
ПОЯСНЕННЯ РІЗНИЦІ МІЖ АЛГОРИТМАМИ
================================================================================

╔════════════════════════════════════════════════════════════════════════════╗
║                          DFS (Depth-First Search)                          ║
╚════════════════════════════════════════════════════════════════════════════╝

ПРИНЦИП РОБОТИ:
• Алгоритм йде максимально глибоко по одній гілці графа перед поверненням
• Використовує стек (або рекурсію) для збереження вершин
• Обирає першого доступного сусіда та продовжує пошук від нього

ПОРЯДОК ОБХОДУ:
• NetworkX повертає сусідів у порядку їх додавання до графа
• Через це DFS може обрати "неоптимальний" напрямок на початку
• Якщо перший напрямок веде до мети, алгоритм його і поверне

ПРИКЛАД (Київ → Лос-Анджелес):
1. Київ → обирає першого сусіда (наприклад, Львів)
2. Львів → обирає свого першого сусіда (Париж)
3. Париж → продовжує пошук через Європу
4. Може пройти через багато проміжних міст перед досягненням США

ХАРАКТЕРИСТИКИ:
✗ НЕ гарантує найкоротший шлях за кількістю вершин
✗ НЕ гарантує мінімальну вагу шляху
✓ Може знайти шлях швидше, якщо "пощастить" з напрямком
✓ Використовує менше пам'яті (глибина графа)

╔════════════════════════════════════════════════════════════════════════════╗
║                         BFS (Breadth-First Search)                         ║
╚════════════════════════════════════════════════════════════════════════════╝

ПРИНЦИП РОБОТИ:
• Алгоритм досліджує всі вершини на поточному рівні перед переходом далі
• Використовує чергу (queue) для збереження вершин
• Систематично перевіряє всі можливі шляхи довжиною 1, потім 2, потім 3...

ПОРЯДОК ОБХОДУ:
• Спочатку перевіряє всіх безпосередніх сусідів стартової вершини
• Потім перевіряє сусідів сусідів (відстань 2)
• І так далі, рівень за рівнем

ПРИКЛАД (Київ → Лос-Анджелес):
1. Рівень 0: Київ
2. Рівень 1: Львів, Харків, Одеса, Париж, Лондон (всі сусіди Києва)
3. Рівень 2: всі сусіди вершин з рівня 1
4. Знаходить Нью-Йорк або інше місто США на рівні 2
5. Знаходить Лос-Анджелес на рівні 3

ХАРАКТЕРИСТИКИ:
✓ ГАРАНТУЄ найкоротший шлях за кількістю вершин
✗ НЕ гарантує мінімальну вагу шляху (для цього потрібен алгоритм Дейкстри)
✓ Систематичний підхід - завжди знаходить оптимум за довжиною
✗ Використовує більше пам'яті (ширина графа)

╔════════════════════════════════════════════════════════════════════════════╗
║                      ЧОМУ ШЛЯХИ САМЕ ТАКІ?                                ║
╚════════════════════════════════════════════════════════════════════════════╝

🔸 DFS може повернути довший шлях:
   • Алгоритм "застряє" на першому напрямку, який обрав
   • Якщо Київ → Львів → Париж → ... виявиться довгим, DFS все одно йде цим шляхом
   • Не повертається, щоб спробувати інші варіанти (Київ → Лондон → ...)

🔸 BFS завжди знаходить найкоротший шлях за кількістю міст:
   • Систематично перевіряє ВСІ можливі маршрути довжиною N перед N+1
   • Як тільки знаходить ціль - це гарантовано найкоротший шлях
   • Для Києва: спочатку перевіряє всі прямі з'єднання (Париж, Лондон)
   • Потім всі маршрути з 1 пересадкою, потім з 2 пересадками і т.д.

🔸 Приклад різниці (Київ → Лос-Анджелес):

   DFS може знайти:
   Київ → Львів → Одеса → Марсель → Ліон → Париж → Нью-Йорк → Лос-Анджелес
   (7 міст, йде "випадковим" шляхом через Європу)

   BFS знайде:
   Київ → Париж → Нью-Йорк → Лос-Анджелес
   або
   Київ → Лондон → Нью-Йорк → Лос-Анджелес
   (4 міста, мінімальна кількість пересадок)

🔸 Вплив структури графа:
   • У нашому графі міста мають різну кількість з'єднань
   • Київ має прямі рейси до Париж та Лондон (хаби)
   • DFS може обрати "непрямий" маршрут через менші міста
   • BFS обов'язково розгляне прямі рейси на першому рівні

╔════════════════════════════════════════════════════════════════════════════╗
║                              ВИСНОВКИ                                      ║
╚════════════════════════════════════════════════════════════════════════════╝

1. BFS КРАЩЕ для пошуку найкоротшого шляху за кількістю вершин
   → Використовуйте для: мінімізації кількості пересадок, оптимізації кроків

2. DFS ШВИДШЕ може знайти БУДЬ-ЯКИЙ шлях (не обов'язково найкоротший)
   → Використовуйте для: перевірки досяжності, пошуку циклів, топологічного сортування

3. ДЛЯ ЗВАЖЕНИХ ГРАФІВ (з часом/відстанню) - використовуйте АЛГОРИТМ ДЕЙКСТРИ
   → Ні DFS, ні BFS не враховують ваги ребер при виборі шляху
   → BFS знаходить найменше міст, але не найменший час/відстань

4. У НАШОМУ ГРАФІ:
   → BFS знаходить маршрути з 3-4 міст (оптимум)
   → DFS може знайти маршрути з 5-7 міст (неоптимальні)
   → Різниця виникає через порядок обходу та структуру графа

================================================================================
