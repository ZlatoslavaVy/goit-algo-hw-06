import networkx as nx
import matplotlib.pyplot as plt
from collections import deque

# ============================================================
# ЗАВДАННЯ 2: Алгоритми DFS і BFS
# ============================================================

print("=" * 80)
print("ЗАВДАННЯ 2: Пошук шляхів алгоритмами DFS і BFS")
print("=" * 80)

# Створення графа (той самий, що в завданні 1)
G = nx.Graph()

# Локації по країнах
ukraine = ["Київ", "Львів", "Одеса", "Харків"]
france = ["Париж", "Марсель", "Ліон"]
england = ["Лондон", "Манчестер", "Ліверпуль"]
usa = ["Нью-Йорк", "Лос-Анджелес", "Чикаго"]

# Додаємо всі вершини
all_locations = ukraine + france + england + usa
G.add_nodes_from(all_locations)

# Внутрішні дороги з вагами
ukraine_roads = [
    ("Київ", "Львів", 7), ("Київ", "Харків", 6), ("Київ", "Одеса", 6),
    ("Львів", "Одеса", 10), ("Харків", "Одеса", 9)
]

france_roads = [
    ("Париж", "Ліон", 5), ("Париж", "Марсель", 8), ("Ліон", "Марсель", 3)
]

england_roads = [
    ("Лондон", "Манчестер", 4), ("Лондон", "Ліверпуль", 4), ("Манчестер", "Ліверпуль", 1)
]

usa_roads = [
    ("Нью-Йорк", "Чикаго", 12), ("Чикаго", "Лос-Анджелес", 4), ("Нью-Йорк", "Лос-Анджелес", 5)
]

# Міжнародні рейси
international_flights = [
    ("Київ", "Париж", 3), ("Київ", "Лондон", 3), ("Львів", "Париж", 2),
    ("Париж", "Лондон", 1), ("Париж", "Нью-Йорк", 8), ("Лондон", "Нью-Йорк", 7),
    ("Одеса", "Марсель", 3)
]

# Додаємо ребра до графа
G.add_weighted_edges_from(ukraine_roads + france_roads + england_roads + usa_roads + international_flights)

# Масштабовані координати для візуалізації
scaled_coordinates = {
    "Лос-Анджелес": (5, 15), "Чикаго": (25, 25), "Нью-Йорк": (35, 22),
    "Ліверпуль": (50, 30), "Манчестер": (52, 28), "Лондон": (55, 22),
    "Париж": (65, 25), "Ліон": (70, 20), "Марсель": (72, 12),
    "Львів": (85, 25), "Київ": (95, 27), "Харків": (105, 26), "Одеса": (97, 15)
}

# Кольори для вершин
color_map = []
for node in G.nodes():
    if node in ukraine:
        color_map.append('#FFD700')
    elif node in france:
        color_map.append('#0055A4')
    elif node in england:
        color_map.append('#2D9D2E')
    elif node in usa:
        color_map.append('#B22234')

# Візуалізація графа
plt.figure(figsize=(18, 10))
pos = scaled_coordinates

nx.draw_networkx_edges(G, pos, width=2, alpha=0.6, edge_color='gray')
nx.draw_networkx_nodes(G, pos, node_color=color_map, node_size=3000, edgecolors='black', linewidths=2)
nx.draw_networkx_labels(G, pos, font_size=11, font_weight='bold')

edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels, font_size=9)

plt.title('RPG World Map - Транспортна мережа', fontsize=16, fontweight='bold')
plt.axis('off')
plt.tight_layout()
plt.show()

print("\n📊 Структура графа:")
print(f"   Кількість вершин: {G.number_of_nodes()}")
print(f"   Кількість ребер: {G.number_of_edges()}")


# ============================================================
# РЕАЛІЗАЦІЯ АЛГОРИТМІВ
# ============================================================

def dfs_with_trace(graph, start, goal, path=[], trace=None):
    """
    Пошук у глибину (Depth-First Search) з трасуванням
    
    Принцип роботи:
    - Йде максимально глибоко по одній гілці перед тим, як повернутися назад
    - Використовує рекурсію або стек
    - Досліджує вершини в порядку, який залежить від порядку сусідів у графі
    """
    if trace is None:
        trace = []
    
    path = path + [start]
    trace.append(start)
    
    if start == goal:
        return path, trace
    
    for neighbor in graph.neighbors(start):
        if neighbor not in path:
            new_path, trace = dfs_with_trace(graph, neighbor, goal, path, trace)
            if new_path:
                return new_path, trace
    return None, trace


def bfs_with_trace(graph, start, goal):
    """
    Пошук у ширину (Breadth-First Search) з трасуванням
    
    Принцип роботи:
    - Досліджує всі вершини на поточному рівні перед переходом на наступний
    - Використовує чергу (queue)
    - Гарантує найкоротший шлях за кількістю вершин
    """
    queue = deque([[start]])
    visited = {start}
    trace = [start]
    
    while queue:
        path = queue.popleft()
        node = path[-1]
        
        if node == goal:
            return path, trace
        
        for neighbor in graph.neighbors(node):
            if neighbor not in visited:
                visited.add(neighbor)
                trace.append(neighbor)
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)
    
    return None, trace


# ============================================================
# ТЕСТУВАННЯ НА РІЗНИХ МАРШРУТАХ
# ============================================================

test_routes = [
    ("Київ", "Лос-Анджелес"),
    ("Київ", "Манчестер"),
    ("Одеса", "Чикаго"),
    ("Львів", "Ліверпуль")
]

print("\n" + "=" * 80)
print("ПОРІВНЯЛЬНИЙ АНАЛІЗ АЛГОРИТМІВ DFS ТА BFS")
print("=" * 80)

for idx, (start_city, goal_city) in enumerate(test_routes, 1):
    print(f"\n{'─' * 80}")
    print(f"ТЕСТ {idx}: Маршрут {start_city} → {goal_city}")
    print(f"{'─' * 80}")
    
    # Виконання DFS
    dfs_path, dfs_trace = dfs_with_trace(G, start_city, goal_city)
    
    # Виконання BFS
    bfs_path, bfs_trace = bfs_with_trace(G, start_city, goal_city)
    
    # Підрахунок ваг
    dfs_weight = sum(G[dfs_path[i]][dfs_path[i+1]]['weight'] for i in range(len(dfs_path)-1))
    bfs_weight = sum(G[bfs_path[i]][bfs_path[i+1]]['weight'] for i in range(len(bfs_path)-1))
    
    # Результати DFS
    print(f"\n🔍 DFS (Depth-First Search):")
    print(f"   Знайдений шлях: {' → '.join(dfs_path)}")
    print(f"   Кількість міст: {len(dfs_path)}")
    print(f"   Загальний час: {dfs_weight} годин")
    print(f"   Порядок обходу: {' → '.join(dfs_trace[:10])}{'...' if len(dfs_trace) > 10 else ''}")
    print(f"   Всього відвідано вершин: {len(dfs_trace)}")
    
    # Результати BFS
    print(f"\n🔍 BFS (Breadth-First Search):")
    print(f"   Знайдений шлях: {' → '.join(bfs_path)}")
    print(f"   Кількість міст: {len(bfs_path)}")
    print(f"   Загальний час: {bfs_weight} годин")
    print(f"   Порядок обходу: {' → '.join(bfs_trace[:10])}{'...' if len(bfs_trace) > 10 else ''}")
    print(f"   Всього відвідано вершин: {len(bfs_trace)}")
    
    # Порівняння
    print(f"\n📊 Порівняння:")
    print(f"   Різниця у кількості міст: {abs(len(dfs_path) - len(bfs_path))}")
    print(f"   Різниця у часі: {abs(dfs_weight - bfs_weight)} годин")
    print(f"   Різниця у відвіданих вершинах: {abs(len(dfs_trace) - len(bfs_trace))}")
    
    if len(bfs_path) < len(dfs_path):
        print(f"   ✅ BFS знайшов коротший шлях за кількістю міст")
    elif len(bfs_path) > len(dfs_path):
        print(f"   ✅ DFS знайшов коротший шлях за кількістю міст")
    else:
        print(f"   ⚖️  Обидва алгоритми знайшли шляхи однакової довжини")


# ============================================================
# ДЕТАЛЬНЕ ПОЯСНЕННЯ РІЗНИЦІ
# ============================================================

print("\n" + "=" * 80)
print("ПОЯСНЕННЯ РІЗНИЦІ МІЖ АЛГОРИТМАМИ")
print("=" * 80)

print("""
╔════════════════════════════════════════════════════════════════════════════╗
║                          DFS (Depth-First Search)                          ║
╚════════════════════════════════════════════════════════════════════════════╝

ПРИНЦИП РОБОТИ:
• Алгоритм йде максимально глибоко по одній гілці графа перед поверненням
• Використовує стек (або рекурсію) для збереження вершин
• Обирає першого доступного сусіда та продовжує пошук від нього

ПОРЯДОК ОБХОДУ:
• NetworkX повертає сусідів у порядку їх додавання до графа
• Через це DFS може обрати "неоптимальний" напрямок на початку
• Якщо перший напрямок веде до мети, алгоритм його і поверне

ПРИКЛАД (Київ → Лос-Анджелес):
1. Київ → обирає першого сусіда (наприклад, Львів)
2. Львів → обирає свого першого сусіда (Париж)
3. Париж → продовжує пошук через Європу
4. Може пройти через багато проміжних міст перед досягненням США

ХАРАКТЕРИСТИКИ:
✗ НЕ гарантує найкоротший шлях за кількістю вершин
✗ НЕ гарантує мінімальну вагу шляху
✓ Може знайти шлях швидше, якщо "пощастить" з напрямком
✓ Використовує менше пам'яті (глибина графа)

╔════════════════════════════════════════════════════════════════════════════╗
║                         BFS (Breadth-First Search)                         ║
╚════════════════════════════════════════════════════════════════════════════╝

ПРИНЦИП РОБОТИ:
• Алгоритм досліджує всі вершини на поточному рівні перед переходом далі
• Використовує чергу (queue) для збереження вершин
• Систематично перевіряє всі можливі шляхи довжиною 1, потім 2, потім 3...

ПОРЯДОК ОБХОДУ:
• Спочатку перевіряє всіх безпосередніх сусідів стартової вершини
• Потім перевіряє сусідів сусідів (відстань 2)
• І так далі, рівень за рівнем

ПРИКЛАД (Київ → Лос-Анджелес):
1. Рівень 0: Київ
2. Рівень 1: Львів, Харків, Одеса, Париж, Лондон (всі сусіди Києва)
3. Рівень 2: всі сусіди вершин з рівня 1
4. Знаходить Нью-Йорк або інше місто США на рівні 2
5. Знаходить Лос-Анджелес на рівні 3

ХАРАКТЕРИСТИКИ:
✓ ГАРАНТУЄ найкоротший шлях за кількістю вершин
✗ НЕ гарантує мінімальну вагу шляху (для цього потрібен алгоритм Дейкстри)
✓ Систематичний підхід - завжди знаходить оптимум за довжиною
✗ Використовує більше пам'яті (ширина графа)

╔════════════════════════════════════════════════════════════════════════════╗
║                      ЧОМУ ШЛЯХИ САМЕ ТАКІ?                                ║
╚════════════════════════════════════════════════════════════════════════════╝

🔸 DFS може повернути довший шлях:
   • Алгоритм "застряє" на першому напрямку, який обрав
   • Якщо Київ → Львів → Париж → ... виявиться довгим, DFS все одно йде цим шляхом
   • Не повертається, щоб спробувати інші варіанти (Київ → Лондон → ...)

🔸 BFS завжди знаходить найкоротший шлях за кількістю міст:
   • Систематично перевіряє ВСІ можливі маршрути довжиною N перед N+1
   • Як тільки знаходить ціль - це гарантовано найкоротший шлях
   • Для Києва: спочатку перевіряє всі прямі з'єднання (Париж, Лондон)
   • Потім всі маршрути з 1 пересадкою, потім з 2 пересадками і т.д.

🔸 Приклад різниці (Київ → Лос-Анджелес):
   
   DFS може знайти:
   Київ → Львів → Одеса → Марсель → Ліон → Париж → Нью-Йорк → Лос-Анджелес
   (7 міст, йде "випадковим" шляхом через Європу)
   
   BFS знайде:
   Київ → Париж → Нью-Йорк → Лос-Анджелес
   або
   Київ → Лондон → Нью-Йорк → Лос-Анджелес
   (4 міста, мінімальна кількість пересадок)

🔸 Вплив структури графа:
   • У нашому графі міста мають різну кількість з'єднань
   • Київ має прямі рейси до Париж та Лондон (хаби)
   • DFS може обрати "непрямий" маршрут через менші міста
   • BFS обов'язково розгляне прямі рейси на першому рівні

╔════════════════════════════════════════════════════════════════════════════╗
║                              ВИСНОВКИ                                      ║
╚════════════════════════════════════════════════════════════════════════════╝

1. BFS КРАЩЕ для пошуку найкоротшого шляху за кількістю вершин
   → Використовуйте для: мінімізації кількості пересадок, оптимізації кроків

2. DFS ШВИДШЕ може знайти БУДЬ-ЯКИЙ шлях (не обов'язково найкоротший)
   → Використовуйте для: перевірки досяжності, пошуку циклів, топологічного сортування

3. ДЛЯ ЗВАЖЕНИХ ГРАФІВ (з часом/відстанню) - використовуйте АЛГОРИТМ ДЕЙКСТРИ
   → Ні DFS, ні BFS не враховують ваги ребер при виборі шляху
   → BFS знаходить найменше міст, але не найменший час/відстань

4. У НАШОМУ ГРАФІ:
   → BFS знаходить маршрути з 3-4 міст (оптимум)
   → DFS може знайти маршрути з 5-7 міст (неоптимальні)
   → Різниця виникає через порядок обходу та структуру графа
""")

print("=" * 80)